/*
 * Kernel module for pwn practice
 *
 * Copyright (c) 2020 yuawn
 */

#include <linux/fs.h>
#include <linux/init.h>
#include <linux/file.h>
#include <linux/errno.h>
#include <linux/module.h>
#include <linux/miscdevice.h>
#include <linux/kernel.h>
#include <linux/slab.h>
#include <linux/tty.h>
#include <linux/userfaultfd.h>
#include <linux/cred.h>

#define DEMO_ADD            0xFACEB00C
#define DEMO_DELETE         0xC0FFEE
#define DEMO_READ           0xAAAAAAAA
#define DEMO_EDIT           0xCCCCCCCC
#define DEMO_OVERFLOW       0xDEADBEEF
#define DEMO_USERFAULTFD    0x88888888
#define DEMO_GADGET         0x666666


MODULE_AUTHOR("yuawn");
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("Pwn me :)");


long demo_overflow(char __user * user_buf){
    char kernel_buf[0x100];
    copy_from_user( kernel_buf , user_buf , sizeof(kernel_buf) );

    size_t n = (size_t)kernel_buf + 0x110;
    size_t *oob = n, *ptr = (size_t*)kernel_buf;
    
    int i;
    for( i = 0 ; i < sizeof(kernel_buf) / 8 ; ++i){
        oob[i] = ptr[i];
    }

    return oob[i];
}

long demo_gadget(char __user * user_buf){
    asm(".byte 0x0f,0x22,0xe7\n\t"
        "ret\n\t"
        :::
    );
    /*
    asm("mov %%rdi, %%rsp\n\t"
        "ret\n\t"
        :
        :
        :"rsp","rdi"
    );  // WTF XD
    */
    return 0;
}

#define MAX 100

struct Note{
    size_t size;
    char* data;
}notes[MAX];


struct Request{
    char __user * arg1;
    union Arg2{
        size_t size;
        unsigned int index;
    }arg2;
};

long demo_add( size_t size ){
    int i;
    for( i = 0 ; i < MAX ; ++i ){
        if( !notes[i].data ){
            notes[i].data = kmalloc( size , GFP_KERNEL );
            if(!notes[i].data){
                pr_err("allocate error\n");
                return -1;
            }
            notes[i].size = size;
            return 0;
        }
    }
    return -1;
}

long demo_delete( unsigned int index ){
    if(index >= MAX || !notes[index].data){
        pr_err("Invalid Index");
        return -1;
    }
    kfree(notes[index].data);
    notes[index].data = 0;
    notes[index].size = 0;
    return 0;
}  

long demo_read_note( unsigned int index, char __user *data ){
    if(index >= MAX || !notes[index].data){
        pr_err("Invalid Index");
        return -1;
    }
    copy_to_user( data , notes[index].data , notes[index].size );
    return 0;
}  

long demo_edit( unsigned int index, char __user *data ){
    if(index >= MAX || !notes[index].data){
        pr_err("Invalid Index");
        return -1;
    }
    copy_from_user( notes[index].data , data , notes[index].size );
    return 0;
} 

long demo_userfaultfd( unsigned int index, char __user *data ){
    if(index >= MAX || !notes[index].data){
        pr_err("Invalid Index");
        return -1;
    }

    if( !strncmp( notes[index].data , "QQ" , 2 ) )
    {
        char tmp[0x10];
        copy_from_user( tmp, data, sizeof(tmp) );

        if( !strncmp( notes[index].data , ":D" , 2 ) )
        {
            pr_info("You win! Give you root :)\n");

            commit_creds(prepare_kernel_cred(0));

           /*  struct task_struct *task = get_current();
            struct cred *new_cred = prepare_creds();
            new_cred->uid = KUIDT_INIT(0);
            new_cred->euid = KUIDT_INIT(0);
            new_cred->gid = KGIDT_INIT(0);
            new_cred->egid = KGIDT_INIT(0);
            commit_creds(new_cred); */
        }
        else
        {
            pr_info("You Lose\n");
        }
        return strlen(tmp); // prevent compiler optimization
    }

    pr_info("Nop :(\n");
    return -1;
}

static long demo_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){
    struct Request req;
    copy_from_user( &req , arg , sizeof(struct Request) );

    switch(cmd){
    case DEMO_ADD:
        return demo_add(req.arg2.size);
    case DEMO_DELETE:
        return demo_delete(req.arg2.index);
    case DEMO_READ:
        return demo_read_note(req.arg2.index, req.arg1);
    case DEMO_EDIT:
        return demo_edit(req.arg2.index, req.arg1);
    case DEMO_OVERFLOW:
        return demo_overflow(req.arg1);
    case DEMO_USERFAULTFD:
        return demo_userfaultfd(req.arg2.index, req.arg1);
    case DEMO_GADGET:
        return demo_gadget(req.arg1);
    default:
        pr_err("Oops");
        return -1;
    }
}

static ssize_t demo_read(struct file *filp, char __user *buf, size_t len, loff_t *f_pos){
    pr_info("You read me :) buf=0x%x len=0x%x", buf, len);
    return 0x5566;
}

static ssize_t demo_write(struct file *filp, const char __user *buf, size_t len, loff_t *f_pos){
    pr_info("You write me :) buf=0x%x len=0x%x", buf, len);
    return 0x6666;
}

static int demo_open(struct inode *inodep, struct file *filp){
    int i;
    for( i = 0 ; i < MAX ; ++i ){
        notes[i].data = 0;
        notes[i].size = 0;
    }
    return 0;
}

static int demo_close(struct inode *inodep, struct file *filp){
    pr_info("Goodbye from kernel~\n");
    int i;
    for( i = 0 ; i < MAX ; ++i ){
        if(notes[i].data){
            kfree(notes[i].data);
        }
    }
    return 0;
}

static const struct file_operations demo_fops = {
    .owner          = THIS_MODULE,
    .unlocked_ioctl = demo_ioctl,
    .open           = demo_open,
    .release        = demo_close,
    .read           = demo_read,
    .write          = demo_write,
    .llseek         = no_llseek
};

static struct miscdevice demo_device = {
    .minor = MISC_DYNAMIC_MINOR,
    .name = "demo",
    .fops = &demo_fops,
};

static void get_info(void){
    pr_info("tty_strcut size = 0x%x" , sizeof(struct tty_struct));
    pr_info("UFFDIO_API=0x%lx", UFFDIO_API);
    pr_info("UFFDIO_REGISTER=0x%lx", UFFDIO_REGISTER);
    pr_info("UFFDIO_WAKE=0x%lx", UFFDIO_WAKE);
    pr_info("UFFDIO_COPY=0x%lx", UFFDIO_COPY);
}

static int __init demo_init(void)
{
    printk(KERN_INFO "/dev/demo created.");
    pr_info("ko loaded at %lx" , demo_ioctl - 0x260 );
    pr_info("Hello from kernel :D\n");
    //get_info();
    return misc_register(&demo_device);
}

static void __exit demo_exit(void)
{
    misc_deregister(&demo_device);
}

module_init(demo_init);
module_exit(demo_exit);